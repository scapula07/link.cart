"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployEthConversionProxy = exports.deployERC20ConversionProxy = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("../src/lib");
const deploy_one_1 = require("./deploy-one");
const currency_1 = require("@requestnetwork/currency");
const types_1 = require("@requestnetwork/types");
function deployERC20ConversionProxy(args, hre) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contractName = 'Erc20ConversionProxy';
        if (!args.chainlinkConversionPathAddress) {
            // FIXME: should try to retrieve information from artifacts instead
            console.error(`Missing ChainlinkConversionPath on ${hre.network.name}, cannot deploy ${contractName}.`);
            return undefined;
        }
        if (!args.erc20FeeProxyAddress) {
            // FIXME: should try to retrieve information from artifacts instead
            console.error(`Missing ERC20FeeProxy on ${hre.network.name}, cannot deploy ${contractName}.`);
            return undefined;
        }
        return (0, deploy_one_1.deployOne)(args, hre, contractName, {
            constructorArguments: [
                args.erc20FeeProxyAddress,
                args.chainlinkConversionPathAddress,
                (_a = process.env.ADMIN_WALLET_ADDRESS) !== null && _a !== void 0 ? _a : (yield (yield hre.ethers.getSigners())[0].getAddress()),
            ],
            artifact: lib_1.erc20ConversionProxy,
            nonceCondition: args.nonceCondition,
            version: '0.1.1',
        });
    });
}
exports.deployERC20ConversionProxy = deployERC20ConversionProxy;
function deployEthConversionProxy(args, hre) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contractName = 'EthConversionProxy';
        if (!args.chainlinkConversionPathAddress) {
            // FIXME: should try to retrieve information from artifacts instead
            console.error(`Missing ChainlinkConversionPath on ${hre.network.name}, cannot deploy ${contractName}.`);
            return;
        }
        if (!args.ethFeeProxyAddress) {
            // FIXME: should try to retrieve information from artifacts instead
            console.error(`Missing ETHFeeProxy on ${hre.network.name}, cannot deploy ${contractName}.`);
            return;
        }
        // The private native token hash is the same as on mainnet
        const nativeTokenNetwork = hre.network.name === 'private' ? 'mainnet' : hre.network.name;
        const nativeTokenHash = (_a = currency_1.CurrencyManager.getDefault().getNativeCurrency(types_1.RequestLogicTypes.CURRENCY.ETH, nativeTokenNetwork)) === null || _a === void 0 ? void 0 : _a.hash;
        if (!nativeTokenHash) {
            console.error(`Cannot guess native token hash on ${hre.network.name}, cannot deploy ${contractName}.`);
            return;
        }
        return (0, deploy_one_1.deployOne)(args, hre, contractName, {
            constructorArguments: [
                args.ethFeeProxyAddress,
                args.chainlinkConversionPathAddress,
                nativeTokenHash,
                args.owner,
            ],
            artifact: lib_1.ethConversionArtifact,
            nonceCondition: args.nonceCondition,
            version: args.version,
        });
    });
}
exports.deployEthConversionProxy = deployEthConversionProxy;
//# sourceMappingURL=conversion-proxy.js.map