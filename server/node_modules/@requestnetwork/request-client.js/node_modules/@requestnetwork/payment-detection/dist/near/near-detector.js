"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NearNativeTokenPaymentDetector = void 0;
const tslib_1 = require("tslib");
const near_info_retriever_1 = require("./retrievers/near-info-retriever");
const native_token_detector_1 = require("../native-token-detector");
const balance_error_1 = require("../balance-error");
// the versions 0.1.0 and 0.2.0 have the same contracts
const CONTRACT_ADDRESS_MAP = {
    ['0.1.0']: '0.1.0',
    ['0.2.0']: '0.2.0',
};
/**
 * Handle payment detection for NEAR native token payment
 */
class NearNativeTokenPaymentDetector extends native_token_detector_1.NativeTokenPaymentDetector {
    constructor(args) {
        super(args);
    }
    /**
     * Extracts the events for an address and a payment reference
     *
     * @param address Address to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param paymentReference The reference to identify the payment
     * @param paymentNetwork the payment network state
     * @returns The balance with events
     */
    extractEvents(eventName, address, paymentReference, _requestCurrency, paymentChain, paymentNetwork) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!address) {
                return {
                    paymentEvents: [],
                };
            }
            const subgraphClient = this.getSubgraphClient(paymentChain);
            if (!subgraphClient) {
                throw new Error(`Could not find graphInfoRetriever for chain ${paymentChain} in payment detector`);
            }
            const infoRetriever = new near_info_retriever_1.NearInfoRetriever(subgraphClient);
            const { paymentEvents } = yield infoRetriever.getTransferEvents({
                paymentReference,
                toAddress: address,
                contractAddress: NearNativeTokenPaymentDetector.getContractName(paymentChain, paymentNetwork.version),
                eventName,
                paymentChain,
            });
            return {
                paymentEvents,
            };
        });
    }
}
exports.NearNativeTokenPaymentDetector = NearNativeTokenPaymentDetector;
NearNativeTokenPaymentDetector.getContractName = (chainName, paymentNetworkVersion = '0.2.0') => {
    var _a;
    const version = NearNativeTokenPaymentDetector.getVersionOrThrow(paymentNetworkVersion);
    const versionMap = {
        aurora: { '0.1.0': 'requestnetwork.near', '0.2.0': 'requestnetwork.near' },
        near: { '0.1.0': 'requestnetwork.near', '0.2.0': 'requestnetwork.near' },
        'aurora-testnet': {
            '0.1.0': 'dev-1626339335241-5544297',
            '0.2.0': 'dev-1631521265288-35171138540673',
        },
        'near-testnet': {
            '0.1.0': 'dev-1626339335241-5544297',
            '0.2.0': 'dev-1631521265288-35171138540673',
        },
    };
    if ((_a = versionMap[chainName]) === null || _a === void 0 ? void 0 : _a[version]) {
        return versionMap[chainName][version];
    }
    throw new balance_error_1.NetworkNotSupported(`Unconfigured near-detector chain '${chainName}' and version '${version}'`);
};
NearNativeTokenPaymentDetector.getVersionOrThrow = (paymentNetworkVersion) => {
    if (!CONTRACT_ADDRESS_MAP[paymentNetworkVersion]) {
        throw Error(`Near payment detection not implemented for version ${paymentNetworkVersion}`);
    }
    return CONTRACT_ADDRESS_MAP[paymentNetworkVersion];
};
//# sourceMappingURL=near-detector.js.map