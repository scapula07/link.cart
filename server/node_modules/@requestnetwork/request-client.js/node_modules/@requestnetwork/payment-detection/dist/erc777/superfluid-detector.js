"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuperFluidPaymentDetector = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const superfluid_retriever_1 = require("./superfluid-retriever");
const reference_based_detector_1 = require("../reference-based-detector");
const payment_reference_calculator_1 = require("../payment-reference-calculator");
const ethers_1 = require("ethers");
/**
 * Handle payment networks with ERC777 Superfluid streaming extension
 */
class SuperFluidPaymentDetector extends reference_based_detector_1.ReferenceBasedDetector {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor({ advancedLogic, currencyManager }) {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC777_STREAM, advancedLogic.extensions.erc777Stream, currencyManager);
    }
    isSubsequentRequest(request) {
        return !!request.extensions[this.paymentNetworkId].values.originalRequestId;
    }
    /**
     * This returns the specific values we store for the ERC777 extensions.
     * @param request The request we are processing
     */
    getSubsequentValues(request) {
        return request.extensions[this.paymentNetworkId].values;
    }
    /**
     * With streaming requests we have a custom balance computation.
     * It is possible to have only one streaming event, start stream,
     * but have 10 requests being created each month for the same stream.
     * For the original request, the first one, the balance computation is easy because we don't care about previous expected balance.
     * For subsequent requests we must take into consideration how many requests were before this one and then attribute the rest of the balance to this one.
     * At this point we are not detecting overpayment because in case of overpayment we are considering that another request should have been created in the series.
     * @param request The request we are calculating balance for
     * @returns Balance object with balance value and payment/refund events
     */
    getBalance(request) {
        const _super = Object.create(null, {
            getBalance: { get: () => super.getBalance }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const totalBalance = yield _super.getBalance.call(this, request);
            if (totalBalance.error) {
                return totalBalance;
            }
            if (totalBalance.balance) {
                const zeroBN = ethers_1.BigNumber.from(0);
                const recurrenceNumber = this.getSubsequentValues(request).recurrenceNumber || 0;
                // This request's balance is the total streamed amount, less all previous requests balance.
                const remainingBalance = ethers_1.BigNumber.from(totalBalance.balance).sub(ethers_1.BigNumber.from(request.expectedAmount).mul(ethers_1.BigNumber.from(recurrenceNumber)));
                // Balance is stricty between 0 and expectedAmount
                const expectedAmount = ethers_1.BigNumber.from(request.expectedAmount);
                const requestBalance = remainingBalance.lt(0)
                    ? zeroBN
                    : remainingBalance.gt(expectedAmount)
                        ? expectedAmount
                        : remainingBalance;
                totalBalance.balance = requestBalance.toString();
            }
            return totalBalance;
        });
    }
    /**
     * Extracts payment events of an address matching an address and a payment reference
     *
     * @param eventName Indicate if it is an address for payment or refund
     * @param address Address to check
     * @param paymentReference The reference to identify the payment
     * @param requestCurrency The request currency
     * @param paymentChain the payment network
     * @returns List of payment events
     */
    extractEvents(eventName, address, paymentReference, requestCurrency, paymentChain) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!address) {
                return {
                    paymentEvents: [],
                };
            }
            const infoRetriever = new superfluid_retriever_1.SuperFluidInfoRetriever(paymentReference, requestCurrency.value, address, eventName, paymentChain);
            const paymentEvents = yield infoRetriever.getTransferEvents();
            return {
                paymentEvents,
            };
        });
    }
    /**
     * In the case of the first, original request that starts the streaming,
     * we calculate the payment reference from its own data: requestId, salt, paymentAddress.
     * In the case of subsequent requests we need to have the same payment reference from the original request,
     * so we need to use the original requests requestId, which we have stored in
     * extension values as originalRequestId, the salt and paymentAddress are the same.
     * @param request The request we need payment reference for
     * @returns The payment reference
     */
    getPaymentReference(request) {
        const { paymentAddress, salt } = this.getPaymentExtension(request).values;
        this.checkRequiredParameter(paymentAddress, 'paymentAddress');
        this.checkRequiredParameter(salt, 'salt');
        const requestId = this.isSubsequentRequest(request)
            ? this.getSubsequentValues(request).originalRequestId
            : request.requestId;
        return payment_reference_calculator_1.default.calculate(requestId, salt, paymentAddress);
    }
}
exports.SuperFluidPaymentDetector = SuperFluidPaymentDetector;
//# sourceMappingURL=superfluid-detector.js.map