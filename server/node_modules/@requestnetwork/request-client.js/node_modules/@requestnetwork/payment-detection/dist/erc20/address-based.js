"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20AddressBasedPaymentDetector = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const address_based_info_retriever_1 = require("./address-based-info-retriever");
const payment_detector_base_1 = require("../payment-detector-base");
/**
 * Handle payment networks with ERC20 based address extension
 */
class ERC20AddressBasedPaymentDetector extends payment_detector_base_1.PaymentDetectorBase {
    /**
     * @param extension The advanced logic payment network extensions
     */
    constructor({ advancedLogic }) {
        super(types_1.ExtensionTypes.PAYMENT_NETWORK_ID.ERC20_ADDRESS_BASED, advancedLogic.extensions.addressBasedErc20);
    }
    /**
     * Creates the extensions data for the creation of this extension
     *
     * @param paymentNetworkCreationParameters Parameters to create the extension
     * @returns The extensionData object
     */
    createExtensionsDataForCreation(paymentNetworkCreationParameters) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.extension.createCreationAction({
                paymentAddress: paymentNetworkCreationParameters.paymentAddress,
                refundAddress: paymentNetworkCreationParameters.refundAddress,
            });
        });
    }
    /**
     * Creates the extensions data to add payment address
     *
     * @param parameters to add payment information
     * @returns The extensionData object
     */
    createExtensionsDataForAddPaymentInformation(parameters) {
        return this.extension.createAddPaymentAddressAction({
            paymentAddress: parameters.paymentAddress,
        });
    }
    /**
     * Creates the extensions data to add refund address
     *
     * @param Parameters to add refund information
     * @returns The extensionData object
     */
    createExtensionsDataForAddRefundInformation(parameters) {
        return this.extension.createAddRefundAddressAction({
            refundAddress: parameters.refundAddress,
        });
    }
    /**
     * Gets the balance and the payment/refund events
     *
     * @param request the request to check
     * @returns the balance and the payment/refund events
     */
    getEvents(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!request.currency.network) {
                request.currency.network = 'mainnet';
            }
            const { paymentAddress, refundAddress } = this.getPaymentExtension(request).values;
            this.checkRequiredParameter(paymentAddress, 'paymentAddress');
            const paymentEvents = yield this.extractTransferEvents(paymentAddress, types_1.PaymentTypes.EVENTS_NAMES.PAYMENT, request.currency.network, request.currency.value);
            const refundEvents = yield this.extractTransferEvents(refundAddress, types_1.PaymentTypes.EVENTS_NAMES.REFUND, request.currency.network, request.currency.value);
            const allPaymentEvents = [...paymentEvents, ...refundEvents];
            return {
                paymentEvents: allPaymentEvents,
            };
        });
    }
    /**
     * Extracts the balance and events of an address
     *
     * @private
     * @param address Address to check
     * @param eventName Indicate if it is an address for payment or refund
     * @param network The id of network we want to check
     * @param tokenContractAddress the address of the token contract
     * @returns The balance
     */
    extractTransferEvents(address, eventName, network, tokenContractAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!address) {
                return [];
            }
            const infoRetriever = new address_based_info_retriever_1.default(tokenContractAddress, address, eventName, network);
            return infoRetriever.getTransferEvents();
        });
    }
}
exports.ERC20AddressBasedPaymentDetector = ERC20AddressBasedPaymentDetector;
//# sourceMappingURL=address-based.js.map