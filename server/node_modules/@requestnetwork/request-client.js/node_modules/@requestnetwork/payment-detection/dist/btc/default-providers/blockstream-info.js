"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockStreamInfoProvider = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const ethers_1 = require("ethers");
const utils_1 = require("@requestnetwork/utils");
// Maximum number of api requests to retry when an error is encountered (ECONNRESET, EPIPE, ENOTFOUND)
const BLOCKSTREAMINFO_REQUEST_MAX_RETRY = 3;
// Delay between retries in ms
const BLOCKSTREAMINFO_REQUEST_RETRY_DELAY = 100;
// Number of transactions per page
const TXS_PER_PAGE = 25;
/**
 * The Bitcoin Info retriever give access to the bitcoin blockchain through the api of blockstream.info
 */
class BlockStreamInfoProvider {
    /**
     * Gets BTC address info using blockstream.info public API
     *
     * @param bitcoinNetworkId The Bitcoin network ID: 0 (mainnet) or 3 (testnet)
     * @param address BTC address to check
     * @param eventName Indicates if it is an address for payment or refund
     * @returns Object containing address info
     */
    getAddressBalanceWithEvents(bitcoinNetworkId, address, eventName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const baseUrl = this.getBaseUrl(bitcoinNetworkId);
            const queryUrl = `${baseUrl}/address/${address}/txs`;
            try {
                const res = yield (0, utils_1.retry)(() => tslib_1.__awaiter(this, void 0, void 0, function* () { return axios_1.default.get(queryUrl); }), {
                    maxRetries: BLOCKSTREAMINFO_REQUEST_MAX_RETRY,
                    retryDelay: BLOCKSTREAMINFO_REQUEST_RETRY_DELAY,
                })();
                // eslint-disable-next-line no-magic-numbers
                if (res.status >= 400) {
                    throw new Error(`Error ${res.status}. Bad response from server ${queryUrl}`);
                }
                let txs = res.data;
                let checkForMoreTransactions = txs.length === TXS_PER_PAGE;
                // if there are 'TXS_PER_PAGE' transactions, need to check the pagination
                while (checkForMoreTransactions) {
                    const lastTxHash = txs[txs.length - 1].txid;
                    const resExtraPage = yield (0, utils_1.retry)(() => tslib_1.__awaiter(this, void 0, void 0, function* () { return fetch(`${baseUrl}/address/${address}/txs/chain/${lastTxHash}`); }), {
                        maxRetries: BLOCKSTREAMINFO_REQUEST_MAX_RETRY,
                        retryDelay: BLOCKSTREAMINFO_REQUEST_RETRY_DELAY,
                    })();
                    // eslint-disable-next-line no-magic-numbers
                    if (resExtraPage.status >= 400) {
                        throw new Error(`Error ${resExtraPage.status}. Bad response from server ${baseUrl}/${address}`);
                    }
                    const extraTxs = yield resExtraPage.json();
                    checkForMoreTransactions = extraTxs.length === TXS_PER_PAGE;
                    // gather all the transactions retrieved
                    txs = txs.concat(extraTxs);
                }
                return this.parse({ address, txs }, eventName);
            }
            catch (err) {
                // eslint-disable-next-line no-console
                console.warn(err.message || err);
                return { balance: '-1', events: [] };
            }
        });
    }
    /**
     * Parses the address information from the data of blockstream.info
     *
     * @param addressInfo Data from blockstream.info
     * @param eventName Indicates if it is an address for payment or refund
     * @returns Balance with events
     */
    parse(addressInfo, eventName) {
        const events = addressInfo.txs
            // exclude the transactions coming from the same address
            .filter((tx) => {
            const autoVin = tx.vin.filter((input) => input.prevout.scriptpubkey_address === addressInfo.address);
            return autoVin.length === 0;
        })
            .reduce((allOutput, tx) => {
            return [
                ...allOutput,
                ...tx.vout.map((output) => ({
                    blockHeight: tx.status.block_height,
                    output,
                    timestamp: tx.status.block_time,
                    txHash: tx.txid,
                })),
            ];
        }, [])
            .filter((output) => output.output.scriptpubkey_address === addressInfo.address)
            .map((output) => ({
            amount: output.output.value.toString(),
            name: eventName,
            parameters: {
                block: output.blockHeight,
                txHash: output.txHash,
            },
            timestamp: output.timestamp,
        }));
        const balance = events
            .reduce((balanceAccumulator, event) => {
            return balanceAccumulator.add(ethers_1.BigNumber.from(event.amount));
        }, ethers_1.BigNumber.from('0'))
            .toString();
        return { balance, events };
    }
    /**
     * Gets the base url to fetch according to the networkId
     *
     * @param bitcoinNetworkId the Bitcoin network ID: 0 (mainnet) or 3 (testnet)
     * @returns The blockchain info URL
     */
    getBaseUrl(bitcoinNetworkId) {
        if (bitcoinNetworkId === 0) {
            return 'https://blockstream.info/api/';
        }
        if (bitcoinNetworkId === 3) {
            return 'https://blockstream.info/testnet/api/';
        }
        throw new Error(`Invalid network 0 (mainnet) or 3 (testnet) was expected but ${bitcoinNetworkId} was given`);
    }
}
exports.BlockStreamInfoProvider = BlockStreamInfoProvider;
//# sourceMappingURL=blockstream-info.js.map